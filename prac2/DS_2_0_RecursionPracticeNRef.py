# https://www.youtube.com/watch?v=uSSC0aKXbWQ

'''
# 재귀 ( recursion )

    자신이 자신을 호출하는 함수

    알고리즘 공부의 통곡의 벽
    재귀가 안되면 재귀를 기반으로 하는 아래의 두가지가 안된다.
        -디바이드 앤 컨커
        -다이나믹 프로그래밍

    *왜쓰는가?
        일반적으로 순환(recursion:재귀)이 반복문보다 느리지만,
        반복문을 쓰면 코드가 더러워지는 반면, 재귀로 적으면 깔끔하고 직관적인 코드를 적을 수 있다.
        (재귀 <-> 반복 간의 상호변환 가능)
        
    * 어떻게 공부하는가?
        하다보면 느니 걱정하지 말고
        
        - 선언형 programming 감각이 필요하다 : 목적(정의)만 설정해 주는 프로그래밍, '컴퓨터 너가 알아서 해'
        - 일단 짜는 것 보다 많이 읽어보는데에 집중 : 선언형 프로그래밍식의 감각을 가지고 읽을 것
        - 많이 접하면 자연스럽게 익숙해진다.
'''

#=================

'''
# 재귀함수 구현의 중요한 세가지

    1. 문제의 정의를 정확히 파악/표기 한다.
            '무엇이란 무엇이다'

    2. 종료조건을 반드시 잘 설정한다.
            '어떤 조건에서 종료한다'

    + 컬스택-호출의 흐름을 따라갈 줄 알아야 한다.
        - 컬스택 : 재귀함수 돌아가는 동안 재귀함수의 호출상태가 계단식으로 쌓이는 스택공간
        
    + Tip ) 알고리즘은 문제정의와 같은 순서로 구현한다는 생각X : 정의상 피보나치의 숫자는 올라가지만, 구현된 알고리즘 상 접근은 내림차순 접근이 될 수 있음.
'''


#==================

'''
# 재귀함수 연습 예제1
'''

# 1. 피보나치 수열 ( 1, 1, 2, 3, 5, 8, 13, 21, 34... n ) : 

    # 문제 정의 : 어떤 수열의 항이, 앞의 두 항의 합과 같은 수열
    
'''
    재귀적 구현 : 
     
        * 재귀는 성능효율이 떨어짐 : O(2^n) : 재귀함수 하나의 반환 당 자기자신을 두번 호출하기 때문에 복잡도는 지수증가함 /
        but 가독성과 원만한 유지보수(클린코드)를 위한 수단이 되어야 함
        
        * 선언적 프로그래밍 (declarative programming) : 재귀는, 문제 정의를 return부에 자기자신을 이용해 구현해주기만 하면 보통 끝나는 원리
        
'''
# def fibo(n):
#     # 종료조건
#     if n < 3:
#         return 1
#     else :
#         return fibo(n-1) + fibo(n-2)    #정의 : 피보나치 수열은 앞의 두 항의 합이 현재의 항의 값이 된다.  
# print(fibo(7))


'''
    반복적 구현  : 
        * 효율상으로는 반복이 유리 : 아래의 예시에서 for문 하나만 돌면 끝나기 때문에 : O(n) // 
        but 가독성과 유지보수의 효율성을 위해 적합한 경우 사용 
        
        * 절차적 프로그래밍 (imperative programming) 
'''
# def fiboLoop(n) :
#     n_minus_1=1
#     n_minus_2=1
#     n_current=1
    
#     for i in range(n):
#         if i < 2:
#             n_current = 1
#         else :
#             n_minus_2 = n_minus_1
#             n_minus_1 = n_current
#             n_current = n_minus_1 + n_minus_2
            
#     return n_current
# print(fiboLoop(7))


#--------------------------------------------

'''
Imperative Programming (명령형) VS Declarative Programming (선언형)

    - 프로그래밍의 언어적 정의이지만 ( Java vs SQL ),
        프로그래밍 코딩 스타일의 방법론을 지칭하는데에도 사용한다.
        
    # 명령형 프로그램은 알고리즘을 명시하고 목표는 명시하지 않는 데 반해,
        EX) 
    
    # 선언형 프로그램은 목표를 명시하고 알고리즘을 명시하지 않는 것이다.
        EX) 출발지는 서울이고 목적지는 부산이다. 100KM로 달리고, 고속도로를 이용한다.
        
    
    %%재귀는 선언적인 프로그래밍으로 짠다 : 자세한 알고리즘은 컴퓨터가 알아서 하도록 맡기는.. 
        : 언제 종료하는지 명시  +  문제를 어떤 식으로 정의하는지 명시
'''

'''
# 하노이 탑 : 대표적 재귀 문제

    문제)))
    - 세개의 기둥과 다양한 크기의 원판이 있다. 퍼즐이 시작하기 전, 한 기둥에 작은 원판이 가장 위에 가도록 순서대로 쌓여있다.
    
    - 목적은 다음의 두가지 조건을 만족시키면서, 한 기둥에 꽂힌 원판들을 그 순서 그대로 다른 한개의 기둥으로 옮겨서 다시 쌓는 것이다.
        이 과정에서 가운데의 기둥을 임시 이동장소로 사용하도록 한다.
    
        -1. 한번에 하나의 원판만 옮길 수 있다.
        -2. 큰 원판이 작은 원판 위에 있어서는 안된다.
        -3. 최소 이동횟수를 사용한다.
    
        
    실제 코딩)))
    - (1) 종료 조건을 잘 설정해야한다 : 마지막 원반을 옮긴 후 끝난다. 
    - (2) 문제의 정의를 선언하는 부분을 잘 듣고, 문제의 정의를 체계적으로 풀어쓴다.
        -가정 : fr : 시작기둥, tmp : 임시기둥, to :목표기둥 으로 지칭한다.
        
            - N개의 원반을 옮기기 위해서는 N-1개의 원반을 fr에서 tmp 기둥으로 옮겨야 한다.
            - 가장 큰 원반이 최종 목적 기둥인 to로 옮겨진다.
            - 이제 tmp기둥에서 N-1개의 원반을 to 기둥으로 옮겨야 한다.
'''
def hanoi_tower(n, fr, tmp, to): 
    
    if n == 1 : # (1) 종료조건 선언 : 마지막 원반(가장 작은 맨 아래의 원반) 일 경우 옮기고 끝난다.
        print('원판 1: %s --> %s'%(fr,to))
    
    else :  # (2) 종료조건이 아닐 경우, 하노이함수 를 실행하라.
        hanoi_tower(n - 1, fr, to, tmp) # n-1개 까지의 원반을 임시기둥을 이용해 tmp로
        print('원판 %d: %s --> %s'%(n,fr,to))   # 하나의 원반을 옮긴다.
        hanoi_tower(n-1, tmp, fr, to)           # n-1개를 fr기둥을 이용해 to로


hanoi_tower(4,'A','B','C') # 네개의 입력을 받는다, 첫번째는 원판의 개수