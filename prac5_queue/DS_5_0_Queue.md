# DS5 - Queue

큐는 선입선출 FIFO 의 자료구조이다.

삽입은 큐의 후단에, 삭제는 전단에서 이루어진다.

선형 큐는 비효율적이다. - 삽입연산 = O(1) - 삭제연산(이동연산 내포) = O(n)

- 컴퓨터에서도 큐는 매우 광범위하게 적용
  - 서비스센터의 콜 큐
  - 프린터와 컴퓨터 사이의 인쇄 작업 큐 ( 버퍼링 )
  - 실시간 비디오 스트리밍에서의 버퍼링
  - 시뮬레이션의 대기열 ( 공항의 비행기들, 은행에서의 대기열 )
  - 통신에서의 데이터 패킷들의 모델링에 이용

# + 원형 큐

배열을 원형으로 사용하는 큐 (개념적인 원형)

    전단과 후단을 위한 2개의 변수를 유지해줘야한다.
        -front : 첫번째 요소에서 하나 앞의 인덱스
        -rear :  마지막 요소의 인덱스

    회전방법 : 시계방향으로 회전하게 됨
        요소 신규 삽입 시 rear에 + 1 (= rear을 한칸밀어 회전시킴) == frnt <- (front + 1) % MAX_QSIZE>
        요소 삭제 시 front에 +1 (= 한칸 밈) == rear <- (rear + 1 ) % MAX_QSIZE

원형 큐는 크기가 정해져 있다. ( 회전이 끝날 시 다시 처음으로 돌아가야 한다 )
=> 들어갈 수 있는 데이터의 수가 제한되어있음 => 애초에 넉넉하게 만들 것

원형 큐가 훨씬 효율적이다. - 삭제 시 전체이동이 발생하지 않고 인덱스만 하나씩 이동하므로
원형 큐는 삽입과 삭제 둘 다 O(1)의 시긴복잡도로 훨씬 효율적이다.

공백상태 : front == rear
포화상태 : front % M == (rear+1) % M
-> 하나의 공간을 항상 비워둔다.

공백상태와 포화상태를 구분하는 방법은? - 포화상태시에도 하나의 공간은 항상 비워두기 때문에 - 공백상태 시에는 front와 rear가 같은 위치를 가리키지만 그 외에는 항상 다른 데이터를 가리킨다. - front가 rear의 하나 앞에 있는 경우 포화상태임을 알 수 있다.


# 큐의 응용 : 너비 우선 탐색 ( BFS )

 큐 응용
    - 이진트리의 레벨순회 (8장)
    - 기수 정렬에서 레코드의 정렬을 위해 사용 (12장)
    - 그래프의 탐색에서 너비 우선 탐색 ( 10장 )
 
 미로 탐색 : 너비우선탐색(BFS, Breadth First Search)
    : 너비 우선탐색은 선입선출(LIFO)이 전제돼야하므로 큐로 만들어야 함


# 파이썬의 queue 모듈 

## 큐 와 스택 클래스를 제공한다.
    사용하기 위해서는 먼저 queue 모듈을 import 해야 한다.
    
큐 객체 생성
Q = queue.Queue(maxsize = 20 ) - 큐 객체 생성 최대크기 20

함수 이름 변경 : 
삽입은 put(), 삭제는 get()

for v in range(1, 10 ):
    Q.put(v)
print('큐의 내용:', end='')

for _ in range(1, 10 ) :
prunt(Q.get(), end = '')
print()